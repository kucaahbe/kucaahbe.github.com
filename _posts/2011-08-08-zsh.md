---

layout: post
title: Z shell configuring and usage

---

Man pages description:
----------------------

| man page                     | description                                                 |
|:----------------------------:|:------------------------------------------------------------|
| <strong>zshmisc</strong>     | programming                                                 |
| <strong>zshexpn</strong>     | variables usage, globbing                                   |
| <strong>zshparam</strong>    | shell variables(like PROMPT etc.)                           |
| <strong>zshoptions</strong>  | commandline options(setopt, no_beep etc.)                   |
| <strong>zshbuiltins</strong> | builtin shell commands(like alias, bindkey, cd, echo, kill) |
| <strong>zshzle</strong>      | editing in commandline                                      |
| <strong>zshcompsys</strong>  | z-shell completing system and it's configuration            |
| <strong>zshmodules</strong>  | loadable extesion modules                                   |
| <strong>zshcontrib</strong>  | user extesions, tips                                        |

Startup
-------

configuration files read order:

1. `/etc/zsh/zshenv`
2. `$ZDOTDIR/.zshenv`
3. `/etc/zsh/zprofile` (if the shell is a <strong>login</strong> shell)
4. `$ZDOTDIR/.zprofile` (if the shell is a <strong>login</strong> shell)
5. `/etc/zsh/zshrc` (if the shell is <strong>interactive</strong>)
6. `$ZDOTDIR/.zshrc` (if the shell is <strong>interactive</strong>)
7. `/etc/zsh/zlogin` (if the shell is a <strong>login</strong> shell)
8. `$ZDOTDIR/.zlogin` (if the shell is a <strong>login</strong> shell)

If ZDOTDIR is unset, HOME is used instead

When a login shell exits, the files $ZDOTDIR/.zlogout and then /etc/zsh/zlogout are read.  This happens with either an explicit exit via the `exit` or `logout` commands, or an implicit exit by reading end-of-file from the terminal.

##### invoking first-time setup

If no personal initialization files exist for the current user, a function is run to help you change some of the most common  settings.   It  won't  appear  if  your administrator  has disabled the zsh/newuser module.  The function is designed to be self-explanatory.  You can run it by hand with `autoload -Uz zsh-newuser-install; zsh-newuser-install -f`.

Commandline editing
-------------------

all about editing in command line is <strong>ZLE</strong> -  <strong>Zsh Line Editor</strong>(builtin zsh module).

<strong>Parameters</strong> used by ZLE(section PARAMETERS USED BY THE SHELL in zshparam man page):

* BAUD
* KEYTIMEOUT
* COLUMNS - the number of columns for this terminal session.  Used for printing select lists and for the line editor
* LINES - the number of lines for this terminal session.  Used for printing select lists and for the line editor
* zle_highlight - used to highlight what you editing

<strong>Commands</strong> used by ZLE:

* <strong>bindkey</strong> - manipulates keymaps and key bindings
* <strong>vared</strong> - invokes ZLE on the value of a shell parameter(like `vared PATH` will give you commandline interface to edit PATH variable)
* <strong>zle</strong> - manipulates editing widgets and allows command line access to ZLE commands from within shell functions

<strong>ZLE</strong> has <strong>six</strong> predefined <strong>keymaps</strong>(keymap in this case is a set of bindings between key sequences and ZLE commands)

| emacs   | EMACS emulation             |
| viins   | vi emulation - insert mode  |
| vicmd   | vi emulation - command mode |
| isearch | incremental search mode     |
| command | read a command name         |
| .safe   | fallback keymap             |

To select keymap use one of the following commands:

{% highlight bash %}
bindkey -e # Selects keymap 'emacs'
bindkey -v # Selects keymap 'viins'
bindkey -a # Selects keymap 'vicmd'
{% endhighlight %}

##### Command-line hotkeys:

{% comment %} {{{ {% endcomment %}
| widget                    | emacs            | vicmd     | viins         | description                                                                                  |
|:--------------------------|:----------------:|:---------:|:-------------:|:---------------------------------------------------------------------------------------------|
| vi-backward-blank-word    |                  |  B        |               | Move backward one word, where  a  word  is  defined  as  a  series  of non-blank characters. |
| backward-char             |  ^B ESC-&#91;D   |           |               | Move backward one character. |
| vi-backward-char          |                  |  ^H h ^?  |  ESC-&#91;D   | Move backward one character, without changing lines. |
| backward-word             |  ESC-B ESC-b     |           |               | Move to the beginning of the previous word. |
| emacs-backward-word       |                  |           |               | Move to the beginning of the previous word. |
| vi-backward-word          |                  |  b        |               | Move to the beginning of the previous word, vi-style. |
| beginning-of-line         |  ^A              |           |               | Move to the beginning of the line.  If already at the beginning of the line, move to the beginning of the previous line, if any. |
| vi-beginning-of-line      |                  |           |               | Move to the beginning of the line, without changing lines. |
| end-of-line               |  ^E              |           |               | Move to the end of the line.  If already at the end of the line,  move to the end of the next line, if any. |
| vi-end-of-line            |                  |  $        |               | Move to the end of the line.  If an argument is given to this command, the cursor will be moved to the end of the line  argument -  1   lines down. |
| vi-forward-blank-word     |                  |  W        |               | Move  forward  one  word,  where  a  word  is  defined  as a series of non-blank characters. |
| vi-forward-blank-word-end |                  |  E        |               | Move to the end of the current word, or, if at the end of the  current word, to the end of the next word, where a word is defined as a series of non-blank characters. |
| forward-char              |  ^F ESC-&#91;C   |           |               | Move forward one character. |
| vi-forward-char           |                  |  space l  |  ESC-&#91;C   | Move forward one character.
| vi-find-next-char         |  ^X^F            |  f        |               | Read a character from the keyboard, and move to the next occurrence of it in the line. |
| vi-find-next-char-skip    |                  |  t        |               | Read  a  character  from  the  keyboard, and move to the position just before the next occurrence of it in the line. |
| vi-find-prev-char         |                  |  F        |               | Read a character from the keyboard, and move to  the  previous  occur‚Äê rence of it in the line. |
| vi-find-prev-char-skip    |                  |  T        |               | Read  a  character  from  the  keyboard, and move to the position just after the previous occurrence of it in the line. |
| vi-first-non-blank        |                  |  ^        |               | Move to the first non-blank character in the line. |
| vi-forward-word           |                  |  w        |               | Move forward one word, vi-style. |
| forward-word              |  ESC-F ESC-f     |           |               | Move to the beginning of the next word.  The editor's idea of  a  word is specified with the WORDCHARS parameter. |
| emacs-forward-word        |                  |           |               | Move to the end of the next word. |
| vi-forward-word-end       |                  |  e        |               | Move to the end of the next word. |
| vi-goto-column            |  ESC-\|          |  \|       |               | Move to the column specified by the numeric argument. |
| vi-goto-mark              |                  |  \`       |               | Move to the specified mark. |
| vi-goto-mark-line         |                  |  '        |               | Move to beginning of the line containing the specified mark. |
| vi-repeat-find            |                  |  ;        |               | Repeat the last vi-find command. |
| vi-rev-repeat-find        |                  |  ,        |               | Repeat the last vi-find command in the opposite direction. |
{% comment %} }}} {% endcomment %}

##### History Control

| beginning-of-buffer-or-history      | ESC-<         | unbound | unbound    | Move to the beginning of the buffer, or if already there, move to the first event in the history list.  |
| beginning-of-line-hist              |               |         |            | Move to the beginning of the line.  If already at the beginning of the buffer, move to the previous history line.  |
| beginning-of-history                |               |         |            | Move to the first event in the history list.  |
| down-line-or-history                | ^N ESC-[B     | j       | ESC-[B     | Move down a line in the buffer, or if already at the bottom line, move to the next event in the history list.  |
| vi-down-line-or-history             | unbound       | +       | unbound    | Move down a line in the buffer, or if already at the bottom line, move to the next event in the history list.  Then move to the first non-blank  character  on the line.  |
| down-line-or-search                 |               |         |            | Move down a line in the buffer, or if already at the bottom line, search forward in the history for a line beginning with the first word in the buffer.  If  called from a function by the zle command with arguments, the first argument is taken as the string for which to search, rather than the first word in the buffer. |
| down-history                        | unbound       | ^N      | unbound    | Move to the next event in the history list.  |
| history-beginning-search-backward   |               |         |            | Search backward in the history for a line beginning with the current line up to the cursor.  This leaves the cursor in its original position.  |
| end-of-buffer-or-history            | ESC-\>        | unbound | unbound    | Move to the end of the buffer, or if already there, move to the last event in the history list. |
| end-of-line-hist                    |               |         |            | Move to the end of the line.  If already at the end of the buffer, move to the next history line.  |
| end-of-history                      |               |         |            | Move to the last event in the history list.  |
| vi-fetch-history                    | unbound       | G       | unbound    | Fetch the history line specified by the numeric argument.  This defaults to the current history line (i.e. the one that isn't history yet). |
| history-incremental-search-backward | ^R ^Xr        | unbound | unbound    | Search backward incrementally for a specified string.  The search is case-insensitive if the search string does not have  uppercase  letters  and  no  numeric argument  was  given.   The string may begin with '^' to anchor the search to the beginning of the line.  When called from a user-defined function returns the following statuses: 0, if the search succeeded; 1, if the search failed; 2, if the search term was a bad  pattern;  3,  if  the  search  was  aborted  by  the send-break command.  |
| history-incremental-search-forward  | ^S ^Xs        | unbound | unbound    | Search forward incrementally for a specified string.  The search is case-insensitive if the search string does not have uppercase letters and no numeric argu‚Äê ment  was given.  The string may begin with '^' to anchor the search to the beginning of the line.  The functions available in the mini-buffer are the same as for history-incremental-search-backward.  |
| history-incremental-pattern-search-forward, |       |         |            | |
| history-incremental-pattern-search-backward | | | | These widgets behave similarly to the corresponding widgets with no -pattern, but the search string typed by the user is treated as a pattern, respecting  the current settings of the various options affecting pattern matching.  See FILENAME GENERATION in zshexpn(1)  for a description of patterns.  If no numeric argu‚Äê ment was given lowercase letters in the search string may match uppercase letters in the history.  The string may begin with '^' to anchor the search  to  the beginning of the line.  The prompt changes to indicate an invalid pattern; this may simply indicate the pattern is not yet complete.  Note that only non-overlapping matches are reported, so an expression with wildcards may return fewer matches on a line than are visible by inspection.  |
| history-search-backward             | ESC-P ESC-p   | unbound | unbound    | Search backward in the history for a line beginning with the first word in the buffer.  If  called from a function by the zle command with arguments, the first argument is taken as the string for which to search, rather than the first word in the buffer.
| vi-history-search-backward          | unbound       | /       | unbound    | Search backward in the history for a specified string.  The string may begin with '^' to anchor the search to the beginning of the line.  A restricted set of editing functions is available in the mini-buffer.  An interrupt signal, as defined by the stty setting,  will stop the search.  The func‚Äê tions  available  in the mini-buffer are: accept-line, backward-delete-char, vi-backward-delete-char, backward-kill-word, vi-backward-kill-word, clear-screen, redisplay, quoted-insert and vi-quoted-insert.  vi-cmd-mode is treated the same as accept-line, and magic-space  is  treated  as  a  space.   Any  other  character  that  is  not  bound  to  self-insert  or self-insert-unmeta will beep and be ignored. If the function is called from vi command mode, the bindings of the current insert mode will be used.  If  called from a function by the zle command with arguments, the first argument is taken as the string for which to search, rather than the first word in the buffer. |
| history-search-forward              | ESC-N ESC-n   | unbound | unbound    | Search forward in the history for a line beginning with the first word in the buffer.  If called from a function by the zle command with arguments, the first argument is taken as the string for which to search, rather than the first word in  the buffer. |
| vi-history-search-forward           | unbound       | ?       | unbound    | Search  forward  in the history for a specified string.  The string may begin with '^' to anchor the search to the beginning of the line. The functions avail‚Äê able in the mini-buffer are the same as for vi-history-search-backward.  Argument handling is also the same as for that command. |
| infer-next-history                  | ^X^N          | unbound | unbound    | Search in the history list for a line matching the current one and fetch the event following it. |
| insert-last-word                    | ESC-_ ESC-.   | unbound | unbound    | Insert the last word from the previous history event at the cursor position.  If a positive numeric argument is given, insert that word from the  end  of  the previous  history event.  If the argument is zero or negative insert that word from the left (zero inserts the previous command word).  Repeating this command replaces the word just inserted with the last word from the history event prior to the one just used; numeric arguments can be used in the same way to pick  a word from that event.  When  called  from  a  shell function invoked from a user-defined widget, the command can take one to three arguments.  The first argument specifies a history offset which applies to successive calls to this widget: if is -1, the default behaviour is used, while if it  is  1,  successive  calls  will  move  forwards through  the  history.   The value 0 can be used to indicate that the history line examined by the previous execution of the command will be reexamined.  Note that negative numbers should be preceded with a '--' argument to avoid confusing them with options.  If two arguments are given, the second specifies the word on the command line in normal array index notation (as a more  natural  alternative  to  the  prefix argument).  Hence 1 is the first word, and -1 (the default)  is the last word.  If a third argument is given, its value is ignored, but it is used to signify that the history offset is relative to the current history line, rather than the one remembered after the previous invocations of insert-last-word.  For example, the default behaviour of the command corresponds to zle insert-last-word -- -1 -1 while the command zle insert-last-word -- -1 1 - always copies the first word of the line in the history immediately before the line being edited.  This has the side effect that later invocations of the wid‚Äê get will be relative to that line. |
| vi-repeat-search                    | unbound       | n       | unbound    | Repeat the last vi history search. |
| vi-rev-repeat-search                | unbound       | N       | unbound    | Repeat the last vi history search, but in reverse. |
| up-line-or-history                  | ^P ESC-&#91;A | k       | ESC-&#91;A | Move up a line in the buffer, or if already at the top line, move to the previous event in the history list. |
| vi-up-line-or-history               | unbound       | -       | unbound    | Move  up  a  line in the buffer, or if already at the top line, move to the previous event in the history list.  Then move to the first non-blank character on the line. |
| up-line-or-search                   |               |         |            | Move up a line in the buffer, or if already at the top line, search backward in the history for a line beginning with the first word in the buffer.  If called from a function by the zle command with arguments, the first argument is taken as the string for which to search, rather than the first word in  the buffer. |
| up-history                          | unbound       | ^P      | unbound    | Move to the previous event in the history list.  history-beginning-search-forward Search forward in the history for a line beginning with the current line up to the cursor.  This leaves the cursor in its original position. |

##### Modifying
| text vi-add-eol         | unbound              | A       | unbound | Move to the end of the line and enter insert mode. |
| vi-add-next             | unbound              | a       | unbound | Enter insert mode after the current cursor position, without changing lines. |
| backward-delete-char    | ^H ^?                | unbound | unbound | Delete the character behind the cursor.   |
| vi-backward-delete-char | unbound              | X       | ^H      | Delete the character behind the cursor, without changing lines.  If in insert mode, this won't delete past the point where insert mode was last entered.  backward-delete-word Delete the word behind the cursor.  backward-kill-line Kill from the beginning of the line to the cursor position.   |
| backward-kill-word      | ^W ESC-^H ESC-^?     | unbound | unbound | Kill the word behind the cursor.   |
| vi-backward-kill-word   | unbound              | unbound | ^W      | Kill the word behind the cursor, without going past the point where insert mode was last entered.   |
| capitalize-word         | ESC-C ESC-c          | unbound | unbound | Capitalize the current word and move past it.   |
| vi-change               | unbound              | c       | unbound | Read  a  movement  command  from  the keyboard, and kill from the cursor position to the endpoint of the movement.  Then enter insert mode.  If the command is vi-change, change the current line.   |
| vi-change-eol           | unbound              | C       | unbound | Kill to the end of the line and enter insert mode.   |
| vi-change-whole-line    | unbound              | S       | unbound | Kill the current line and enter insert mode.   |
| copy-region-as-kill     | ESC-W ESC-w          | unbound | unbound | Copy the area from the cursor to the mark to the kill buffer.  If called from a ZLE widget function in the form 'zle copy-region-as-kill string' then string will be taken as the text to copy to the kill buffer.  The  cur‚Äê sor, the mark and the text on the command line are not used in this case.   |
| copy-prev-word          | ESC-^_               | unbound | unbound | Duplicate the word to the left of the cursor.  copy-prev-shell-word Like  copy-prev-word,  but  the word is found by using shell parsing, whereas copy-prev-word looks for blanks. This makes a difference when the word is quoted and contains spaces.   |
| vi-delete               | unbound              | d       | unbound | Read a movement command from the keyboard, and kill from the cursor position to the endpoint of the movement.  If the command is vi-delete, kill  the  current line.  delete-char Delete the character under the cursor.   |
| vi-delete-char          | unbound              | x       | unbound | Delete the character under the cursor, without going past the end of the line.  delete-word Delete the current word.   |
| down-case-word          | ESC-L ESC-l          | unbound | unbound | Convert the current word to all lowercase and move past it.   |
| kill-word               | ESC-D ESC-d          | unbound | unbound | Kill the current word.  gosmacs-transpose-chars Exchange the two characters behind the cursor.   |
| vi-indent               | unbound              | >       | unbound | Indent a number of lines.   |
| vi-insert               | unbound              | i       | unbound | Enter insert mode.   |
| vi-insert-bol           | unbound              | I       | unbound | Move to the first non-blank character on the line and enter insert mode.   |
| vi-join                 | ^X^J                 | J       | unbound | Join the current line with the next one.   |
| kill-line               | ^K                   | unbound | unbound | Kill from the cursor to the end of the line.  If already on the end of the line, kill the newline character.   |
| vi-kill-line            | unbound              | unbound | ^U      | Kill from the cursor back to wherever insert mode was last entered.   |
| vi-kill-eol             | unbound              | D       | unbound | Kill from the cursor to the end of the line.  kill-region Kill from the cursor to the mark.   |
| kill-buffer             | ^X^K                 | unbound | unbound | Kill the entire buffer.   |
| kill-whole-line         | ^U                   | unbound | unbound | Kill the current line.   |
| vi-match-bracket        | ^X^B                 | %       | unbound | Move  to the bracket character (one of {}, () or [])  that matches the one under the cursor.  If the cursor is not on a bracket character, move forward without going past the end of the line to find one, and then go to the matching bracket.   |
| vi-open-line-above      | unbound              | O       | unbound | Open a line above the cursor and enter insert mode.   |
| vi-open-line-below      | unbound              | o       | unbound | Open a line below the cursor and enter insert mode.   |
| vi-oper-swap-case       |                      |         |         | Read a movement command from the keyboard, and swap the case of all characters from the cursor position to the endpoint of the movement.  If the movement com‚Äê mand is vi-oper-swap-case, swap the case of all characters on the current line.   |
| overwrite-mode          | ^X^O                 | unbound | unbound | Toggle between overwrite mode and insert mode.   |
| vi-put-before           | unbound              | P       | unbound | Insert the contents of the kill buffer before the cursor.  If the kill buffer contains a sequence of lines (as opposed to characters), paste it above the cur‚Äê rent line.   |
| vi-put-after            | unbound              | p       | unbound | Insert the contents of the kill buffer after the cursor.  If the kill buffer contains a sequence of lines (as opposed to characters), paste it below the  cur‚Äê rent line.   |
| quoted-insert           | ^V                   | unbound | unbound | Insert the next character typed into the buffer literally.  An interrupt character will not be inserted.   |
| vi-quoted-insert        | unbound              | unbound | ^Q ^V   | Display a '^' at the cursor position, and insert the next character typed into the buffer literally.  An interrupt character will not be inserted.   |
| quote-line              | ESC-'                | unbound | unbound | Quote the current line; that is, put a ''' character at the beginning and the end, and convert all ''' characters to ''\'''.   |
| quote-region            | ESC-"                | unbound | unbound | Quote the region from the cursor to the mark.   |
| vi-replace              | unbound              | R       | unbound | Enter overwrite mode.   |
| vi-repeat-change        | unbound              | .       | unbound | Repeat  the  last  vi mode text modification.  If a count was used with the modification, it is remembered.  If a count is given to this command, it overrides the remembered count, and is remembered for future uses of this command.  The cut buffer specification is similarly remembered.   |
| vi-replace-chars        | unbound              | r       | unbound | Replace the character under the cursor with a character read from the keyboard.   |
| self-insert             | printable characters | unbound | printable characters and some control characters | Insert a character into the buffer at the cursor position.   |
| self-insert-unmeta      | ESC-^I ESC-^J ESC-^M | unbound | unbound | Insert a character into the buffer after stripping the meta bit and converting ^M to ^J.   |
| vi-substitute           | unbound              | s       | unbound | Substitute the next character(s).   |
| vi-swap-case            | unbound              | ~       | unbound | Swap the case of the character under the cursor and move past it.   |
| transpose-chars         | ^T                   | unbound | unbound | Exchange the two characters to the left of the cursor if at end of line, else exchange the character under the cursor with the character to the left.   |
| transpose-words         | ESC-T ESC-t          | unbound | unbound | Exchange the current word with the one before it.   |
| vi-unindent             | unbound              | <       | unbound | Unindent a number of lines.   |
| up-case-word            | ESC-U ESC-u          | unbound | unbound | Convert the current word to all caps and move past it.   |
| yank                    | ^Y                   | unbound | unbound | Insert the contents of the kill buffer at the cursor position.   |
| yank-pop                | ESC-y                | unbound | unbound | Remove the text just yanked, rotate the kill-ring (the history of previously killed text)  and yank the new top.  Only works following yank or yank-pop.   |
| vi-yank                 | unbound              | y       | unbound | Read a movement command from the keyboard, and copy the region from the cursor position to the endpoint of the movement into the kill buffer.  If the  command is vi-yank, copy the current line.   |
| vi-yank-whole-line      | unbound              | Y       | unbound | Copy the current line into the kill buffer.   |
| vi-yank-eol             |                      |         |         | Copy the region from the cursor position to the end of the line into the kill buffer.  Arguably, this is what Y should do in vi, but it isn't what it actually does.   |

##### Completion

| accept-and-menu-complete  |                 |         |         | In a menu completion, insert the current completion into the buffer, and advance to the next possible completion.   |
| complete-word             |                 |         |         | Attempt completion on the current word.   |
| delete-char-or-list       | ^D              | unbound | unbound | Delete the character under the cursor.  If the cursor is at the end of the line, list possible completions for the current word.   |
| expand-cmd-path           |                 |         |         | Expand the current command to its full pathname.   |
| expand-or-complete        | TAB             | unbound | TAB     | Attempt shell expansion on the current word.  If that fails, attempt completion.   |
| expand-or-complete-prefix |                 |         |         | Attempt shell expansion on the current word up to cursor.   |
| expand-history            | ESC-space ESC-! | unbound | unbound | Perform history expansion on the edit buffer.   |
| expand-word               | ^X*             | unbound | unbound | Attempt shell expansion on the current word.   |
| list-choices              | ESC-^D          | ^D =    | ^D      | List possible completions for the current word.   |
| list-expand               | ^Xg ^XG         | ^G      | ^G      | List the expansion of the current word.   |
| magic-space               |                 |         |         | Perform history expansion and insert a space into the buffer.  This is intended to be bound to space.   |
| menu-complete             |                 |         |         | Like complete-word, except that menu completion is used.  See the MENU_COMPLETE option.   |
| menu-expand-or-complete   |                 |         |         | Like expand-or-complete, except that menu completion is used.   |
| reverse-menu-complete     |                 |         |         | Perform menu completion, like menu-complete, except that if a menu completion is already in progress, move to the previous completion rather than the next.   |
| end-of-list               |                 |         |         | When a previous completion displayed a list below the prompt, this widget can be used to move the prompt below the list.   |

##### Misc

| accept-and-hold               | ESC-A ESC-a       | unbound | unbound | Push the contents of the buffer on the buffer stack and execute it.   |
| accept-and-infer-next-history |                   |         |         | Execute the contents of the buffer.  Then search the history list for a line matching the current one and push the event following onto the buffer stack.   |
| accept-line                   | ^J ^M             | ^J ^M   | ^J ^M   | Finish editing the buffer.  Normally this causes the buffer to be executed as a shell command.   |
| accept-line-and-down-history  | ^O                | unbound | unbound | Execute the current line, and push the next history event on the the buffer stack.   |
| auto-suffix-remove            |                   |         |         | If  the  previous  action added a suffix (space, slash, etc.)  to the word on the command line, remove it.  Otherwise do nothing.  Removing the suffix ends any active menu completion or menu selection.  This widget is intended to be called from user-defined widgets to enforce a desired suffix-removal behavior.   |
| auto-suffix-retain            |                   |         |         | If the previous action added a suffix (space, slash, etc.)  to the word on the command line, force it to be preserved.  Otherwise do  nothing.   Retaining  the suffix ends any active menu completion or menu selection.  This widget is intended to be called from user-defined widgets to enforce a desired suffix-preservation behavior.   |
| beep                          |                   |         |         | Beep, unless the BEEP option is unset. |
| vi-cmd-mode                   | ^X^V              | unbound | ^[      | Enter command mode; that is, select the 'vicmd' keymap.  Yes, this is bound by default in emacs mode.   |
| vi-caps-lock-panic            |                   |         |         | Hang until any lowercase key is pressed.  This is for vi users without the mental capacity to keep track of their caps lock key (like the author).   |
| clear-screen                  | ^L ESC-^L         | ^L      | ^L      | Clear the screen and redraw the prompt.   |
| describe-key-briefly          |                   |         |         | Reads a key sequence, then prints the function bound to that sequence.   |
| exchange-point-and-mark       | ^X^X              | unbound | unbound | Exchange  the  cursor  position (point)  with the position of the mark.  Unless a negative prefix argument is given, the region between point and mark is acti‚Äê vated so that it can be highlighted.  If a zero prefix argument is given, the region is activated but point and mark are not swapped.   |
| execute-named-cmd             | ESC-x             | :       | unbound | Read the name of an editor command and execute it.  A restricted set of editing functions is available in the mini-buffer.  Keys are looked up in the  special command  keymap,  and  if not found there in the main keymap.  An interrupt signal, as defined by the stty setting, will abort the function. The allowed func‚Äê tions are: backward-delete-char, vi-backward-delete-char, clear-screen, redisplay, quoted-insert, vi-quoted-insert, backward-kill-word, vi-backward-kill-word, kill-whole-line,  vi-kill-line,  backward-kill-line,  list-choices,  delete-char-or-list,  complete-word,  accept-line,  expand-or-complete and expand-or-com‚Äê plete-prefix.  kill-region kills the last word, and vi-cmd-mode is treated the same as accept-line.  The space and tab characters, if not bound to one  of  these  functions, will  complete  the  name  and  then  list  the  possibilities  if  the  AUTO_LIST  option  is  set.   Any other character that is not bound to self-insert or self-insert-unmeta will beep and be ignored.  The bindings of the current insert mode will be used.  Currently this command may not be redefined or called by name.   |
| execute-last-named-cmd        | ESC-z             | unbound | unbound | Redo the last function executed with execute-named-cmd.  Currently this command may not be redefined or called by name.   |
| get-line                      | ESC-G ESC-g       | unbound | unbound | Pop the top line off the buffer stack and insert it at the cursor position.   |
| pound-insert                  | unbound           | #       | unbound | If there is no # character at the beginning of the buffer, add one to the beginning of each line.  If there is one, remove a # from each line  that  has  one.  In either case, accept the current line.  The INTERACTIVE_COMMENTS option must be set for this to have any usefulness.   |
| vi-pound-insert               |                   |         |         | If  there  is no # character at the beginning of the current line, add one.  If there is one, remove it.  The INTERACTIVE_COMMENTS option must be set for this to have any usefulness.   |
| push-input                    |                   |         |         | Push the entire current multiline construct onto the buffer stack and return to the top-level (PS1)  prompt.  If the current parser construct is only a  single line, this is exactly like push-line.  Next time the editor starts up or is popped with get-line, the construct will be popped off the top of the buffer stack and loaded into the editing buffer.   |
| push-line                     | ^Q ESC-Q ESC-q    | unbound | unbound | Push the current buffer onto the buffer stack and clear the buffer.  Next time the editor starts up, the buffer will be popped off the top of the buffer stack and loaded into the editing buffer.   |
| push-line-or-edit             |                   |         |         | At the top-level (PS1)  prompt, equivalent to push-line.  At a secondary (PS2)  prompt, move the entire current multiline construct into the editor buffer.  The latter is equivalent to push-input followed by get-line.   |
| read-command                  |                   |         |         | Only useful from a user-defined widget.  A keystroke is read just as in normal operation, but instead of the command being executed the name  of  the  command that  would  be executed is stored in the shell parameter REPLY.  This can be used as the argument of a future zle command.  If the key sequence is not bound, status 1 is returned; typically, however, REPLY is set to undefined-key to indicate a useless key sequence.   |
| recursive-edit                |                   |         |         | Only useful from a user-defined widget.  At this point in the function, the editor regains control until one of the  standard  widgets  which  would  normally cause  zle  to exit (typically an accept-line caused by hitting the return key) is executed.  Instead, control returns to the user-defined widget.  The status returned is non-zero if the return was caused by an error, but the function still continues executing and hence may tidy up.   This  makes  it  safe  for  the user-defined widget to alter the command line or key bindings temporarily.  The following widget, caps-lock, serves as an example.  self-insert-ucase() { LBUFFER+=${(U)KEYS[-1]} } integer stat zle -N self-insert self-insert-ucase zle -A caps-lock save-caps-lock zle -A accept-line caps-lock zle recursive-edit stat=$?  zle -A .self-insert self-insert zle -A save-caps-lock caps-lock zle -D save-caps-lock (( stat )) && zle send-break return $stat This  causes  typed  letters  to  be inserted capitalised until either accept-line (i.e. typically the return key)  is typed or the caps-lock widget is invoked again; the later is handled by saving the old definition of caps-lock as save-caps-lock and then rebinding it to invoke accept-line.  Note that an error  from the recursive edit is detected as a non-zero return status and propagated by using the send-break widget.   |
| redisplay                     | unbound           | ^R      | ^R      | Redisplays the edit buffer.   |
| reset-prompt                  | unbound           | unbound | unbound | Force  the prompts on both the left and right of the screen to be re-expanded, then redisplay the edit buffer.  This reflects changes both to the prompt vari‚Äê ables themselves and changes in the expansion of the values (for example, changes in time or directory, or changes to the value of variables  referred  to  by the prompt).  Otherwise,  the prompt is only expanded each time zle starts, and when the display as been interrupted by output from another part of the shell (such as a job notification) which causes the command line to be reprinted.   |
| send-break                    | ^G ESC-^G         | unbound | unbound | Abort the current editor function, e.g. execute-named-command, or the editor itself, e.g. if you are in vared. Otherwise abort  the  parsing  of  the  current line.   |
| run-help                      | ESC-H ESC-h       | unbound | unbound | Push the buffer onto the buffer stack, and execute the command 'run-help cmd', where cmd is the current command.  run-help is normally aliased to man.   |
| vi-set-buffer                 | unbound           | "       | unbound | Specify  a buffer to be used in the following command.  There are 35 buffers that can be specified: the 26 'named' buffers "a to "z and the nine 'queued' buf‚Äê fers "1 to "9.  The named buffers can also be specified as "A to "Z.  When a buffer is specified for a cut command, the text being cut replaces the previous contents of the specified buffer.  If a named buffer is specified using a capital, the newly cut text is appended to the buffer instead of overwriting it.  If no buffer is specified for a cut command, "1 is used, and the contents of "1 to "8 are each shifted along one buffer; the contents of "9 is lost.   |
| vi-set-mark                   | unbound           | m       | unbound | Set the specified mark at the cursor position.   |
| set-mark-command              | ^@                | unbound | unbound | Set  the  mark at the cursor position.  If called with a negative prefix argument, do not set the mark but deactivate the region so that it is no longer high‚Äê lighted (it is still usable for other purposes).  Otherwise the region is marked as active.   |
| spell-word                    | ESC-$ ESC-S ESC-s | unbound | unbound | Attempt spelling correction on the current word.   |
| undefined-key                 |                   |         |         | This command is executed when a key sequence that is not bound to any command is typed.  By default it beeps.   |
| undo                          | ^_ ^Xu ^X^U       | unbound | unbound | Incrementally undo the last text modification.   |
| redo                          |                   |         |         |  Incrementally redo undone text modifications. |
| vi-undo-change                | unbound           | u       | unbound | Undo the last text modification.  If repeated, redo the modification.   |
| what-cursor-position          | ^X=               | unbound | unbound | Print the character under the cursor, its code as an octal, decimal and hexadecimal number, the current cursor position within the buffer and  the  column  of the cursor in the current line.   |
| where-is                      |                   |         |         | Read  the  name  of  an editor command and and print the listing of key sequences that invoke the specified command.  A restricted set of editing functions is available in the mini-buffer.  Keys are looked up in the special command keymap, and if not found there in the main keymap.   |
| which-command                 | ESC-?             | unbound | unbound | Push the buffer onto the buffer stack, and execute the command 'which-command cmd'. where cmd is the current command.  which-command is  normally  aliased  to whence.   |
| vi-digit-or-beginning-of-line | unbound           | 0       | unbound | If the last command executed was a digit as part of an argument, continue the argument.  Otherwise, execute vi-beginning-of-line.   |

[Source](http://zsh.sourceforge.net/Doc/Release/Zsh-Line-Editor.html#Movement)

History setup
-------------

Command prompt
--------------

PS1  - for left prompt  
RPS1 - for right prompt  
look into zshmisc(EXPANSION OF PROMPT SEQUENCES)  

Completion system
-----------------
TODO

#### Links

* [zsh offical site](http://www.zsh.org/)
* [zsh on sourceforge.net](http://zsh.sourceforge.net/)
* [zsh online manual](http://zsh.sourceforge.net/Doc/Release/zsh_toc.html)
* [Z Shell user's guide](http://zsh.sourceforge.net/Guide/zshguide.html)
* [ZSH wiki](http://zshwiki.org/home/)

{% comment %} vim:foldmethod=marker:nowrap {% endcomment %}
